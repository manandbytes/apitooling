package org.eclipse.pde.apitools.ant.tasks;

import java.io.File;
import java.io.PrintWriter;
import java.io.StringWriter;

import org.apache.tools.ant.BuildException;
import org.eclipse.ant.core.Task;
import org.eclipse.osgi.util.NLS;
import org.eclipse.pde.api.tools.internal.provisional.model.IApiBaseline;
import org.eclipse.pde.api.tools.internal.provisional.model.IApiComponent;
import org.eclipse.pde.apitools.ant.internal.BaselineResolutionDebugger;
import org.eclipse.pde.apitools.ant.internal.RootReport;
import org.eclipse.pde.apitools.ant.tasks.old.Messages;
import org.eclipse.pde.apitools.ant.util.BaselineUtils;
import org.eclipse.pde.apitools.ant.util.ReportUtils;
import org.eclipse.pde.apitools.ant.util.ToolingException;

public class DebugBaselineTask extends Task {
	public static final String REPORT_NAME = "DEBUG_BASELINE";
	public static final String TEMPORARY_BASELINE = "temporaryBaseline";

	private String baseline;
	private String reports;
	private String includeListLocation;
	private String excludeListLocation;
	private IApiComponent[] filtered;
	
	/**
	 * Execute this ant task using the baseline, reports, and other data set via setter methods
	 * @throws BuildException
	 */
	public void execute() throws BuildException {
		checkArgs();
		IApiBaseline baselineObj = BaselineUtils.createBaseline( createRandomBaselineName(), baseline, null);
		execute(baselineObj);
	}
	
	private String createRandomBaselineName() {
		return TEMPORARY_BASELINE + Long.toHexString(Double.doubleToLongBits(Math.random()));
	}
	
	/**
	 * Execute this ant task ignoring baseline and instead providing a file array
	 * @param files
	 * @throws BuildException
	 */
	public void execute(File[] files) throws BuildException {
		execute(BaselineUtils.createBaseline(createRandomBaselineName(), files));
	}
	
	
	/**
	 * Internal method to debug a given baseline and output reports int he proper folder. 
	 * 
	 * @param baselineObj
	 * @throws BuildException
	 */
	protected void execute(IApiBaseline baselineObj) throws BuildException {
		IApiComponent[] included = BaselineUtils.getFilteredElements(
				baselineObj, includeListLocation, excludeListLocation);
		
		BaselineResolutionDebugger dbg = new BaselineResolutionDebugger();
		RootReport report = dbg.debugBaseline(baselineObj, included);
		try {
			ReportUtils.saveReport(report, getReportName(reports, REPORT_NAME));
		} catch(ToolingException te) {
			throw new BuildException(te);
		}
	}
	
	/*
	 * It's possible this task is called multiple times on different baselines, 
	 * so just keeping this open to prevent one report from overwriting a previous one
	 */
	protected File getReportName(String reports, String prefix) {
		File f = null;
		int i = 0;
		do {
			f = new File(reports, prefix + (i == 0 ? "" : i));
			i++;
		} while( f.exists());
		return f;
	}
	
	protected void checkArgs() throws BuildException {
		if (this.baseline == null
				|| this.reports == null) {
			StringWriter out = new StringWriter();
			PrintWriter writer = new PrintWriter(out);
			writer.println(
				NLS.bind(Messages.printArguments,
					new String[] {
						this.baseline,
						this.reports,
					})
			);
			writer.flush();
			writer.close();
			throw new BuildException(String.valueOf(out.getBuffer()));
		}
	}	

	
	/**
	 * Set the exclude list location.
	 * 
	 * <p>The exclude list is used to know what bundles should excluded from the xml report generated by the task
	 * execution. Lines starting with '#' are ignored from the excluded elements.</p>
	 * <p>The format of the exclude list file looks like this:</p>
	 * <pre>
	 * # DOC BUNDLES
	 * org.eclipse.jdt.doc.isv
	 * org.eclipse.jdt.doc.user
	 * org.eclipse.pde.doc.user
	 * org.eclipse.platform.doc.isv
	 * org.eclipse.platform.doc.user
	 * # NON-ECLIPSE BUNDLES
	 * com.ibm.icu
	 * com.jcraft.jsch
	 * javax.servlet
	 * javax.servlet.jsp
	 * ...
	 * </pre>
	 * <p>The location is set using an absolute path.</p>
	 *
	 * @param excludeListLocation the given location for the excluded list file
	 */
	public void setExcludeList(String excludeListLocation) {
		this.excludeListLocation = excludeListLocation;
	}
	
	/**
	 * Set the include list location.
	 * 
	 * <p>The include list is used to know what bundles should included from the xml report generated by the task
	 * execution. Lines starting with '#' are ignored from the included elements.</p>
	 * <p>The format of the include list file looks like this:</p>
	 * <pre>
	 * # DOC BUNDLES
	 * org.eclipse.jdt.doc.isv
	 * org.eclipse.jdt.doc.user
	 * org.eclipse.pde.doc.user
	 * org.eclipse.platform.doc.isv
	 * org.eclipse.platform.doc.user
	 * # NON-ECLIPSE BUNDLES
	 * com.ibm.icu
	 * com.jcraft.jsch
	 * javax.servlet
	 * javax.servlet.jsp
	 * ...
	 * </pre>
	 * <p>The location is set using an absolute path.</p>
	 *
	 * @param includeListLocation the given location for the included list file
	 */
	public void setIncludeList(String includeListLocation) {
		this.includeListLocation = includeListLocation;
	}

	
	
	/**
	 * Set the location of the reference baseline.
	 * 
	 * <p>It can be a .zip, .jar, .tgz, .tar.gz file, or a directory that corresponds to 
	 * the Eclipse installation folder. This is the directory is which you can find the 
	 * Eclipse executable.
	 * </p>
	 * <p>The location is set using an absolute path.</p>
	 *
	 * @param baselineLocation the given location for the reference baseline to analyze
	 */
	public void setBaseline(String baselineLocation) {
		this.baseline = baselineLocation;
	}
	/**
	 * Set the output location where the reports will be generated.
	 * 
	 * <p>Once the task is completed, reports are available in this directory using a structure
	 * similar to the filter root. A sub-folder is created for each component that has problems
	 * to be reported. Each sub-folder contains a file called "report.xml". </p>
	 * 
	 * <p>A special folder called "allNonApiBundles" is also created in this folder that contains a xml file called
	 * "report.xml". This file lists all the bundles that are not using the API Tools nature.</p>
	 * 
	 * @param baselineLocation the given location for the reference baseline to analyze
	 */
	public void setReport(String reportLocation) {
		this.reports = reportLocation;
	}

}
